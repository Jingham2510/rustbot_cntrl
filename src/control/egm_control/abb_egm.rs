// This file is @generated by prost-build.

#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EgmHeader {
    /// sequence number (to be able to find lost messages)
    #[prost(uint32, optional, tag = "1")]
    pub seqno: Option<u32>,
    /// controller send time stamp in ms
    #[prost(uint32, optional, tag = "2")]
    pub tm: Option<u32>,
    #[prost(
        enumeration = "egm_header::MessageType",
        optional,
        tag = "3",
        default = "MsgtypeUndefined"
    )]
    pub mtype: Option<i32>,
}
/// Nested message and enum types in `EgmHeader`.
pub mod egm_header {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MessageType {
        MsgtypeUndefined = 0,
        /// for future use
        MsgtypeCommand = 1,
        /// sent by robot controller
        MsgtypeData = 2,
        /// sent by sensor for position guidance
        MsgtypeCorrection = 3,
        /// sent by sensor for path correction
        MsgtypePathCorrection = 4,
    }
    impl MessageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MsgtypeUndefined => "MSGTYPE_UNDEFINED",
                Self::MsgtypeCommand => "MSGTYPE_COMMAND",
                Self::MsgtypeData => "MSGTYPE_DATA",
                Self::MsgtypeCorrection => "MSGTYPE_CORRECTION",
                Self::MsgtypePathCorrection => "MSGTYPE_PATH_CORRECTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> Option<Self> {
            match value {
                "MSGTYPE_UNDEFINED" => Some(Self::MsgtypeUndefined),
                "MSGTYPE_COMMAND" => Some(Self::MsgtypeCommand),
                "MSGTYPE_DATA" => Some(Self::MsgtypeData),
                "MSGTYPE_CORRECTION" => Some(Self::MsgtypeCorrection),
                "MSGTYPE_PATH_CORRECTION" => Some(Self::MsgtypePathCorrection),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EgmCartesian {
    #[prost(double, required, tag = "1")]
    pub x: f64,
    #[prost(double, required, tag = "2")]
    pub y: f64,
    #[prost(double, required, tag = "3")]
    pub z: f64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EgmQuaternion {
    #[prost(double, required, tag = "1")]
    pub u0: f64,
    #[prost(double, required, tag = "2")]
    pub u1: f64,
    #[prost(double, required, tag = "3")]
    pub u2: f64,
    #[prost(double, required, tag = "4")]
    pub u3: f64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EgmEuler {
    #[prost(double, required, tag = "1")]
    pub x: f64,
    #[prost(double, required, tag = "2")]
    pub y: f64,
    #[prost(double, required, tag = "3")]
    pub z: f64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EgmClock {
    #[prost(uint64, required, tag = "1")]
    pub sec: u64,
    #[prost(uint64, required, tag = "2")]
    pub usec: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EgmTimestamp {
    #[prost(uint64, optional, tag = "1")]
    pub sec: Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub nsec: Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EgmPose {
    #[prost(message, optional, tag = "1")]
    pub pos: Option<EgmCartesian>,
    #[prost(message, optional, tag = "2")]
    pub orient: Option<EgmQuaternion>,
    #[prost(message, optional, tag = "3")]
    pub euler: Option<EgmEuler>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgmCartesianSpeed {
    #[prost(double, repeated, packed = "false", tag = "1")]
    pub value: Vec<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgmJoints {
    #[prost(double, repeated, packed = "false", tag = "1")]
    pub joints: Vec<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgmExternalJoints {
    #[prost(double, repeated, packed = "false", tag = "1")]
    pub joints: Vec<f64>,
}
/// Is used for position streaming (source: controller) and position guidance (source: sensor)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgmPlanned {
    #[prost(message, optional, tag = "1")]
    pub joints: Option<EgmJoints>,
    #[prost(message, optional, tag = "2")]
    pub cartesian: Option<EgmPose>,
    #[prost(message, optional, tag = "3")]
    pub external_joints: Option<EgmJoints>,
    #[prost(message, optional, tag = "4")]
    pub time: Option<EgmClock>,
    #[prost(message, optional, tag = "5")]
    pub time_stamp: Option<EgmTimestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgmSpeedRef {
    #[prost(message, optional, tag = "1")]
    pub joints: Option<EgmJoints>,
    #[prost(message, optional, tag = "2")]
    pub cartesians: Option<EgmCartesianSpeed>,
    #[prost(message, optional, tag = "3")]
    pub external_joints: Option<EgmJoints>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EgmPathCorr {
    /// Sensor measurement (x, y, z) relative the sensor tool coordinate system
    #[prost(message, required, tag = "1")]
    pub pos: EgmCartesian,
    /// Sensor measurement age in ms
    #[prost(uint32, required, tag = "2")]
    pub age: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgmFeedBack {
    #[prost(message, optional, tag = "1")]
    pub joints: Option<EgmJoints>,
    #[prost(message, optional, tag = "2")]
    pub cartesian: Option<EgmPose>,
    #[prost(message, optional, tag = "3")]
    pub external_joints: Option<EgmJoints>,
    #[prost(message, optional, tag = "4")]
    pub time: Option<EgmClock>,
    #[prost(message, optional, tag = "5")]
    pub time_stamp: Option<EgmTimestamp>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EgmMotorState {
    #[prost(enumeration = "egm_motor_state::MotorStateType", required, tag = "1")]
    pub state: i32,
}
/// Nested message and enum types in `EgmMotorState`.
pub mod egm_motor_state {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MotorStateType {
        MotorsUndefined = 0,
        MotorsOn = 1,
        MotorsOff = 2,
    }
    impl MotorStateType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MotorsUndefined => "MOTORS_UNDEFINED",
                Self::MotorsOn => "MOTORS_ON",
                Self::MotorsOff => "MOTORS_OFF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> Option<Self> {
            match value {
                "MOTORS_UNDEFINED" => Some(Self::MotorsUndefined),
                "MOTORS_ON" => Some(Self::MotorsOn),
                "MOTORS_OFF" => Some(Self::MotorsOff),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EgmMciState {
    #[prost(
        enumeration = "egm_mci_state::MciStateType",
        required,
        tag = "1",
        default = "MciUndefined"
    )]
    pub state: i32,
}
/// Nested message and enum types in `EgmMCIState`.
pub mod egm_mci_state {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MciStateType {
        MciUndefined = 0,
        MciError = 1,
        MciStopped = 2,
        MciRunning = 3,
    }
    impl MciStateType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MciUndefined => "MCI_UNDEFINED",
                Self::MciError => "MCI_ERROR",
                Self::MciStopped => "MCI_STOPPED",
                Self::MciRunning => "MCI_RUNNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> Option<Self> {
            match value {
                "MCI_UNDEFINED" => Some(Self::MciUndefined),
                "MCI_ERROR" => Some(Self::MciError),
                "MCI_STOPPED" => Some(Self::MciStopped),
                "MCI_RUNNING" => Some(Self::MciRunning),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EgmRapidCtrlExecState {
    #[prost(
        enumeration = "egm_rapid_ctrl_exec_state::RapidCtrlExecStateType",
        required,
        tag = "1",
        default = "RapidUndefined"
    )]
    pub state: i32,
}
/// Nested message and enum types in `EgmRapidCtrlExecState`.
pub mod egm_rapid_ctrl_exec_state {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RapidCtrlExecStateType {
        RapidUndefined = 0,
        RapidStopped = 1,
        RapidRunning = 2,
    }
    impl RapidCtrlExecStateType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::RapidUndefined => "RAPID_UNDEFINED",
                Self::RapidStopped => "RAPID_STOPPED",
                Self::RapidRunning => "RAPID_RUNNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> Option<Self> {
            match value {
                "RAPID_UNDEFINED" => Some(Self::RapidUndefined),
                "RAPID_STOPPED" => Some(Self::RapidStopped),
                "RAPID_RUNNING" => Some(Self::RapidRunning),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgmTestSignals {
    #[prost(double, repeated, packed = "false", tag = "1")]
    pub signals: Vec<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgmMeasuredForce {
    #[prost(bool, optional, tag = "1")]
    pub fc_active: Option<bool>,
    #[prost(double, repeated, packed = "false", tag = "2")]
    pub force: Vec<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgmCollisionInfo {
    #[prost(bool, optional, tag = "1")]
    pub collsion_triggered: Option<bool>,
    #[prost(double, repeated, packed = "false", tag = "2")]
    pub coll_det_quota: Vec<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgmRapiDdata {
    #[prost(bool, optional, tag = "1")]
    pub dig_val: Option<bool>,
    #[prost(double, repeated, packed = "false", tag = "2")]
    pub dnum: Vec<f64>,
}
/// Robot controller outbound message, sent from the controller to the sensor during position guidance and position streaming
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgmRobot {
    #[prost(message, optional, tag = "1")]
    pub header: Option<EgmHeader>,
    #[prost(message, optional, tag = "2")]
    pub feed_back: Option<EgmFeedBack>,
    #[prost(message, optional, tag = "3")]
    pub planned: Option<EgmPlanned>,
    #[prost(message, optional, tag = "4")]
    pub motor_state: Option<EgmMotorState>,
    #[prost(message, optional, tag = "5")]
    pub mci_state: Option<EgmMciState>,
    #[prost(bool, optional, tag = "6")]
    pub mci_convergence_met: Option<bool>,
    #[prost(message, optional, tag = "7")]
    pub test_signals: Option<EgmTestSignals>,
    #[prost(message, optional, tag = "8")]
    pub rapid_exec_state: Option<EgmRapidCtrlExecState>,
    #[prost(message, optional, tag = "9")]
    pub measured_force: Option<EgmMeasuredForce>,
    #[prost(double, optional, tag = "10")]
    pub utilization_rate: Option<f64>,
    #[prost(uint32, optional, tag = "11")]
    pub move_index: Option<u32>,
    #[prost(message, optional, tag = "12")]
    pub collision_info: Option<EgmCollisionInfo>,
    #[prost(message, optional, tag = "13")]
    pub rapi_dfrom_robot: Option<EgmRapiDdata>,
    #[prost(message, optional, tag = "14")]
    pub torque_ref: Option<EgmJoints>,
}
/// Robot controller inbound message, sent from sensor to the controller during position guidance
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgmSensor {
    #[prost(message, optional, tag = "1")]
    pub header: Option<EgmHeader>,
    #[prost(message, optional, tag = "2")]
    pub planned: Option<EgmPlanned>,
    #[prost(message, optional, tag = "3")]
    pub speed_ref: Option<EgmSpeedRef>,
    #[prost(message, optional, tag = "4")]
    pub rapi_dto_robot: Option<EgmRapiDdata>,
}
/// Robot controller inbound message, sent from sensor during path correction
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EgmSensorPathCorr {
    #[prost(message, optional, tag = "1")]
    pub header: Option<EgmHeader>,
    #[prost(message, optional, tag = "2")]
    pub path_corr: Option<EgmPathCorr>,
}
